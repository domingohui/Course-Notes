<!DOCTYPE html>
<html>
  <head>
    <title>CS 246 :: Structures & Classes</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, shrink-to-fit=no, initial-scale=1">
    <meta name="Course Notes" content="">
    <meta name="Raphael" content="">

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/simple-sidebar.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=cpp&lang=bsh&skin=sunburst"></script>
  </head>
  <body>
    <div id="wrapper">
      <!-- Sidebar -->
      <div id="sidebar-wrapper">
        <ul class="sidebar-nav">
          <li class="sidebar-brand">
              <a href="../../index.html">UW Couse Notes</a>
          </li>
          <li><a href="./shell.html">The Shell</a></li>
          <li><a href="#">C++</a></li>
          <li><a href="#">Unix tools</a></li>
          <li><a href="#">Software Engineering</a></li>
        </ul>
      </div>
      <!-- /#sidebar-wrapper -->

      <!-- Page Content -->
      <div id="page-content-wrapper">
          <div class="container-fluid">
            <div class="row">
              <div class="col-lg-12">
                <a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Toggle Menu</a>
                <h1 id="title_text">Structures & Classes</h1><br />

                <!-- Table of Contents -->
                <div id="contents">
                  <h1>Table of Contents</h1>
                  <ol id="nav">
                    <li><a href="#1">Structures</a></li>
                    <li><a href="#2">Classes</a></li>
                    <li><a href="#3">Class Member Functions</a></li>
                    <li><a href="#4">Public and Private Members</a></li>
                    <li><a href="#5">Accessor and Mutator Functions</a></li>
                    <li><a href="#6">Structures vs. Classes</a></li>
                    <li><a href="#7">Constructors</a></li>
                    <li><a href="#8">Static Modifer</a></li>
                  </ol>
                </div>
                <!--Table of Contents -->

                <h2 id="1">Structures</h2>
                Structures are another form of "aggregate" data type, like arrays.  It differs from arrays in that it allows for a collection of values of <i>different</i> types.  Structs, like arrays, are treated as a single item.  One major difference is that a struct <u>must</u> be <i>defined</i> prior to declaring any variables.
                <h3>Defining a Struct</h3>
                When a struct is defined, no memory is allocated.  It is a "placeholder" for what the struct will look like.  The structure definition will have a list of member names in the enclosing braces.  Note that a semi-colon must follow the closing brace.  An example of a structure definition is:
<pre class="prettyprint">
struct CDAccount {  // struct keyword
  // member names
  double balance;
  double interestRate;
  int term;
};  // Dont forget semi-colon
</pre>
                <h3>Initializing a Struct</h3>
                Structures can be initialized at declaration:
                <code class="prettyprint">CDAccount account = { 12.50, 0.05, 3 };</code><br />
                The initialization provides the initial data to all member variables.

                <h3>Accessing a Struct</h3>
                Once a structure definition is given, the structure type can be used to declare <b>structure values</b>, which is a collection of <b>member values</b> (one for each member name).  These <b>structure variables</b> can be accessed with the dot operator <code>.</code>: e.g.
<pre class="prettyprint">
CDAccount account;  // declaration
account.balance;  // accesses "balance" member variable
</pre>
                <h3>Structure Assignment</h3>
                Given 2 objects of the same structure type, assignments copy each member variable from one to the other.  e.g. <code class="prettyprint">account1 = account2;</code>


                <h2 id="2">Classes</h2>
                Classes are like structures with <b>member functions</b>.  The value of a class variable is called an <b>object</b>. Classes are integral to OOP whose focus is on objects containing data and operations.

                The definition of a class is very similar to that of structures:
<pre class="prettyprint">
class DayofYear {
public:
  int month;
  int day;
  void output();  // member function
};  // Don't forget semicolon</pre>
                Declaring objects is the same as other variables, e.g. <code class="prettyprint">DayofYear today, birthday;</code><br />
                Objects include:
                <ul>
                  <li>
                    Data - Member variables
                  </li>
                  <li>
                    Operations - Member functions
                  </li>
                </ul>

                Class member variables are accessed in the same way as structs, with the dot operator. e.g. <code class="prettyprint">today.output();</code> invokes the member function <code>output()</code> of the object <code>today</code>.

                <h2 id="3">Class Member Functions</h2>
                Class member functions must be defined/implemented after the class definition.  Typically, function declarations are placed in the interface file while the implementations are kept elsewhere (information hiding).<br />
                Syntax: <code class="prettyprint">Return_Type Class_Name::Function_Name Parameter_List){}</code>
                <br />Notice the <b>scope resolution operator</b> <code>::</code>.  It tells the compiler which class the member is from.  The item before <code>::</code> (the class name) is called the <b>type qualifier</b>. e.g.
<pre class="prettyprint">
void DayofYear::output() {
  cout << "Month: " << month << ", Day: " << day;
}
</pre>

                <h3>Classes and OOP</h3>
                <ol>
                  <li>
                    Information Hiding
                    <ul>
                      <li>
                        Details of how operations work are not known to users
                      </li>
                      <li>
                        Accomplished by restricting access to member variables (private/protected)
                      </li>
                    </ul>
                  </li>
                  <li>
                    Data Abstraction
                    <ul>
                      <li>
                        User knows how to use ADT/class, but details of how data is manipulated within ADT/class is not known to user
                      </li>
                      <li>
                        Can be used as a technique for identifying which information should be hidden
                      </li>
                    </ul>
                  </li>
                  <li>
                    Encapsulation
                    <ul>
                      <li>
                        Aggregates data and operations but keeps some details hidden (through information hiding) and others visible
                      </li>
                      <li>
                        Objects are an encapsulation of data values and operations
                      </li>
                    </ul>
                  </li>
                </ol>

                <h2 id="4">Public and Private Members</h2>
                <h3>Private Members</h3>
                Member variables in classes are <b>private</b> by default (opposite of structures whose members are public by default), or under the <code class="prettyprint">private:</code> tag, which means they are accessible only inside the class.  They cannot be accessed outside the class definition via the dot operator.  This upholds the principles of OOP as it hides data from the client and allows manipulation only through public member functions.
                <h3>Public Members</h3>
                Public member variables are specified under the <code class="prettyprint">public:</code> tag, which makes them accessible from outside the class by the client through the dot operator. e.g.
<pre class="prettyprint">
class DayofYear {
public:
  void input();
  void output();
private:
  int month;  // data is private
  int day;
};
DayofYear date;
cin >> date.month;  // not allowed
date.input();  // allowed
</pre>
                <h3>Member Initialization</h3>
                Member initialization allow us to set default values for member vars by initializing them within the class definition.
                <pre class="prettyprint">
class DayofYear {
int month = 1;  // member initialization
int day = 1;
};</pre>

                <h2 id="5">Accessor and Mutator Functions</h2>
                Accessor and Mutator functions are used to set/modify and retrieve the private member data of objects.
                <ul>
                  <li>
                    Accessor Functions - allows client to retrieve data from object.  Should not change class data (represented by making function a constant function via <code>const</code> keyword after function parameter list.  Explained more <a href="./function.html#7">here</a>.)
                  </li>
                  <li>
                    Mutator Function - allows client to change the data
                  </li>
                </ul>
<pre class="prettyprint">
class DayofYear {
public:
  void input();
  void output();
  // Mutator Functions
  void setMonth (int month);
  void setDay (int day);
  // Accessor Functions
  int getMonth() const;
  int getDay() const;
private:
  int month;  // data is private
  int day;
};</pre>


                <h2 id="6">Structures vs. Classes</h2>
                <table>
                  <tr>
                    <th>Property</th>
                    <th></th>
                    <th>Structure</th>
                    <th>Class</th>
                  </tr>
                  <tr>
                    <td>Default Scope</td>
                    <td></td>
                    <td>Public</td>
                    <td>Private</td>
                  </tr>
                  <tr>
                    <td>Member Functions</td>
                    <td></td>
                    <td>None</td>
                    <td>Interface member functions are public</td>
                  </tr>
                </table>

                <h2 id="7">Constructors</h2>
                Constructors are member functions that are called when an object of that class is declared.  It initializes some or all member variables.  It can also be used to validate the data provided to ensure that the appropriate data is assigned to the member variables.  A constructor is defined like any other function except:
                <ol>
                  <li>
                    must have the same name as class
                  </li>
                  <li>
                    cannot return a value
                  </li>
                  <li>
                    no type given (not even void)
                  </li>
                </ol>
                We can then declare objects of that type with the initialization parameters provided.  Note that we cannot call constructors like other member functions.
<pre class="prettyprint">
class DayofYear {
public:
  DayofYear(int month, int day); // ctor initializes month and day
private:
  int month;  // data is private
  int day;
};
DayofYear date1(3, 14), date2(2, 29);
// The following is ILLEGAL
DayofYear date1;
date1.DayofYear(7, 4);
</pre>
                A contructor definition looks like this:
<pre class="prettyprint">
DayofYear::DayofYear(int monthValue, int dayValue) {
  month = monthValue;
  day = dayValue;
}</pre>
                <h3>Initialization Section</h3>
                We can also use an <b>initialization section</b> to initalize member data.  The initialization section is placed after the parameter list and before the opening braces.  It consists of a colon followed by a list of some or all member vars separated by commas. Each member varaiable included is then followed by its initializing value in parenthesis.  This is favoured over the other method as it is more efficient: less overhead (explained later). e.g.
<pre class="prettyprint">
DayofYear::DayofYear(int monthValue, int dayValue)
  : month(monthValue), day(dayValue) {}</pre>

                <h3>Overloaded Constructors</h3>
                Constructors can also be overloaded like other functions.  This allows for multiple contructors of different parameters.  The <i>default</i> constructor (without parameters) should <u>not</u> be declared with any brackets, else the compiler will mistake it for a function.
<pre class="prettyprint">
DayofYear date1;  // Correct
DayofYear date1(); // Wrong
</pre>
                <h3>Constructor Delegation</h3>
                When dealing with multiple constructors, we might encounter repetitive code across constructors.  To reduce this, we can apply <b>constructor delegation</b>.  We call the constructor we are delegating to as the <i>only</i> item in the initialization section.
<pre class="prettyprint">
class Max {
  int max, min, middle;
};
Max::Max(int my_max) {
  max = my_max > 0 ? my_max : 10;
}
Max(int my_max, int my_min) : Max(my_max) {
  min = my_min > 0 && my_min < max ? my_min : 1;
}
Max(int my_max, int my_min, int my_middle) : Max (my_max, my_min){
  middle = my_middle < max && my_middle > min ? my_middle : 5;
}</pre>

                <h3>Explicit Constructor Calls</h3>
                Constructors can be called even after object has been declared. e.g. <code class="prettyprint">holiday = DayofYear(5, 5);</code><br />
                Note that for the default constructor with no arguments, we <u>do</u> have to include parenthesis this time.

                <h3>Default Constructor</h3>
                The <b>default constructor</b> is the constructor without any arguments.  It is auto-generated only if no other constructors are defined.  As a rule, it should always be defined to allow for accidental declarations of classes without parameters, i.e. <code class="prettyprint">DayofYear date;</code>

                <h2 id="8">Static Modifier</h2>
                <h3>Static Variables</h3>
                <b>Static member variables</b> are shared by all objects of that class.  When one object changes it, all objects sees that change. To make a variable static, we place the <code>static</code> keyword before its type. Here are some potential uses:
                <ol>
                  <li>
                    for object of a class to communicate with each other and coordinate actions.
                  </li>
                  <li>
                    track how often a member function is called across all objects
                  </li>
                  <li>
                    count how many objects exist at a given time
                  </li>
                </ol>
                Static variables are initialized <i>outside</i> the class definition.  This ensures that the class' author performs the initializing of the static variables and no other programmer can initialize them (static vars cannot be initialized twice).

                <h3>Static Functions</h3>
                Static member functions are member functions that does not need access to an object's data but still needs to be a member of that class.  It can be called outside of the class without having to have a calling object.  Note that it can only use <i>static member variables</i> and not any variable that depends on a calling object.
<pre class="prettyprint">
class DayofYear {
public:
  static void printTodayDate();
private:
  int month;
  int day;
  static int numOfDates;
};
int DayofYear::numOfDates = 0; // initialize static var
DayofYear::printTodayDate(); // call static function
</pre>

                


              </div>
            </div>
        </div>
        <footer class="footer">
          <a href="#top">Back to Top</a>
          <p id="last_modified"></p>
        </footer>
      </div>
      <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- JS Script -->
    <script src="../../js/scripts.js"></script>

  </body>
</html>
